#!/usr/bin/env sh

# shellcheck shell=ash
# This script assumes at least `local` extension is enabled.

# Lock file used when installing packages
readonly DOTFILE_LOCKFILE_NAME="dotfile.lock"

readonly DOTFILE_AVAILABLE_SOURCES="native dotfile"

readonly DOTFILE_DEBUG=${DEBUG:-0}
readonly DOTFILE_LOG_LEVEL=${LOG_LEVEL:-2}

# XDG base directories
readonly XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
readonly XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}

# Color constants
readonly BLACK=$(tput setaf 0)
readonly RED=$(tput setaf 1)
readonly GREEN=$(tput setaf 2)
readonly YELLOW=$(tput setaf 3)
readonly BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly CYAN=$(tput setaf 6)
readonly WHITE=$(tput setaf 7)

# Text style constants
readonly BOLD=$(tput bold)
readonly UNDERLINE=$(tput smul)
readonly BLINK=$(tput blink)

# Reset test to normal style
readonly NORMAL=$(tput sgr0)

## Logging functions
################################

# Source logging library
. _functions/logging.sh

## Utility functions
################################

# Source stack library
. _functions/stack.sh

# Source checker library
. _functions/checks.sh

## Dependency list creator
depends() {
    # Syntax: depends <src> <packages>...
    #   <src> can be `native`, `dotfile`, `pip`, `gem`, etc.
    #   There must be a function called install_<src> to install the
    #   dependencies.

    local src package arrayname
    src="$1"
    package="$2"
    shift 2

    # Allow packages from arbitrary sources
    arrayname="depends_$src"
    append "$package" to "$arrayname"

    # If there are more than one packages, recursively add more
    [ $# -ne 0 ] && depends "$src" "$@"
}

## Append one item to a space-separated list
append() {
    # Syntax: append <item> to <array>

    local item to array occurrence
    item=$1
    to=$2
    array=$3
    
    if [ $# -ne 3 ] || [ "$to" != "to" ]; then
        error "Usage: append <item> to <array>"
        exit 1
    fi

    if contains "$array" "$item"; then
        debug "$item already exists in $array."
        return
    fi

    eval "$array=\"\${$array} $item\""
}

## Check if the "array" contains the item
contains() {
    # Syntax: contains <array> <item>
    local array item occurrence
    array=$1
    item=$2
    occurrence=$(printf "%s\n" $(eval "echo \"\$$array\"") | grep -c "^$item$")

    [ "$occurrence" -ne 0 ]
}

## Sources package information file
source_dotpkg() {
    . "$1/dotpkg"
}

## Install native package dependencies
install_native() {
    info "Installing native package dependencies..."
    info "You might need to provide your sudo credential here."
    # TODO: support other platforms as well
    #sudo pacman -Sy "$@"
    sudo apt-get install "$@"
}

## Install dotfile package dependencies
install_dotfile() {
    info "Installing dotfile dependencies..."
    for pkg in $depends_dotfile; do
        dotfile_install "$pkg"
    done
}

## Action handlers
################################

dotfile_usage() {
    cat 1>&2 <<EOF
USAGE:
    $(basename "$0") <command>

COMMANDS:
    init         Initializes this machine.
    install      Installs a package to this machine.
    uninstall    Uninstalls a package from this machine.
    update       Updates the repository to the most recent version.
    remove       Remove all packages and try to make as clean as possible.
    help         Displays this help message.
EOF

    if [ "$DOTFILE_DEBUG" -ne 0 ]; then
        echo "    shell        Create a REPL instance. Useful when debugging functions."
    fi
}

dotfile_init() {
    # Initialization routine
    # Things to do:
    # 1. Create configuration file $XDG_CONFIG_HOME/dotfile.conf
    # 2. Create package folder $XDG_DATA_HOME/dotfile/
    # 3. Verify all necessary binaries are here (git, stow, etc.)
    # 4. Symbolic link itself to ~/.local/bin

    # Create basic configuration file
    if ! is_file "$XDG_CONFIG_HOME/dotfile.conf"; then
        info "Dotfile configuration file is not found. Creating..."
        ensure mkdir -p "$XDG_CONFIG_HOME"
        ensure touch "$XDG_CONFIG_HOME/dotfile.conf"

        info "Setting dotfile home directory as:"
        echo "dotfile_home=$(dirname "$(realpath "$0")")" \
            | ensure tee "$XDG_CONFIG_HOME/dotfile.conf" \
            1>&2
    fi

    # Create directory where package data will be stored
    if ! is_directory "$XDG_DATA_HOME/dotfile"; then
        info "Dotfile package storage is not found. Creating..."
        ensure mkdir -p "$XDG_DATA_HOME/dotfile"
    fi

    # git is required to update packages
    if ! is_command git; then
        info "git does not exist. Attempting to install..."
        ensure install_native git
    fi

    # stow is required to make symbolic links
    if ! is_command stow; then
        info "stow does not exist. Attempting to install..."
        ensure install_native stow
    fi

    # This script is going to be installed in local PATH
    if ! is_symlink "$HOME/.local/bin/dotfile"; then
        info "Installing dotfile binary to local binary directory..."
        ensure mkdir -p "$HOME/.local/bin"
        ensure ln -s "$(realpath "$0")" "$HOME/.local/bin/dotfile"
    fi
}

dotfile_install() {
    local pkg
    pkg="$1"

    # Check package sanity
    if ! is_directory $pkg; then
        error "Dotfile package $pkg is not found! Aborting..."
        exit 2
    fi

    if ! is_file "$pkg/dotpkg"; then
        error "$pkg is not a valid dotfile package. Aborting..."
        exit 2
    fi

    # Check circular dependency
    if contains "$(stack_name ancestors)" "$pkg"; then
        warn "Circular dependency detected! Ignoring the last attempt to install $pkg..."
        warn "You may want to fix the package description file to resolve this issue."
        return
    fi

    # If already visited, then do nothing
    if contains "visited" "$pkg"; then
        debug "Package $pkg is already installed by other package. Skipping..."
        return
    fi

    # Load dotfile description file
    source_dotpkg "$pkg"

    # Mark current package as visited
    append "$pkg" to "visited"

    # Find out the direct dependencies
    local difference
    difference="$depends_dotfile"
    for visited_pkg in $visited; do
        difference=$(echo "$difference" | sed -E -e "s/^$visited_pkg | $visited_pkg|$visited_pkg | $visited_pkg\$//g")
    done

    # Install dependencies first
    for dependency in $difference; do
        dotfile_install $dependency
    done

    # Unset pre- and post-installation hooks
    unset -f pre_install post_install

    # Source dotfile description file again to restore changed hooks
    source_dotpkg "$pkg"

    # Run the pre-installation hook
    maybe pre_install

    debug "Installing dotfile package $pkg..."
    maybe post_install

    return
}

dotfile_uninstall() {
    error "This feature is not implemented yet."
    return
}

dotfile_update() {
    error "This feature is not implemented yet."
    return
}

dotfile_remove() {
    error "This feature is not implemented yet."
    return
}

dotfile_shell() {
    if [ "$DOTFILE_DEBUG" -eq 0 ]; then
        error "Opening shell is not supported if DEBUG environment variable is not set!"
        exit 1
    fi

    while true; do
        read -r -p "dotfile> " line

        [ "$line" = "exit" ] && break

        eval "$line"
    done
}

## Entrypoint
################################

# Take the first positional argument
action="$1"
if [ -z "$action" ]; then
    error "You must supply at least one command!"
    dotfile_usage
    return 1
fi
shift

case "$action" in
    help)
        echo "dotfile -- automatic dotfile installer, because I am lazy as fuck"
        echo ""
        dotfile_usage
        ;;

    init)
        dotfile_init "$@"
        ;;

    install)
        dotfile_install "$@"
        ;;

    uninstall)
        dotfile_uninstall "$@"
        ;;

    update)
        dotfile_update "$@"
        ;;

    remove)
        dotfile_remove "$@"
        ;;

    shell)
        dotfile_shell "$@"
        ;;

    *)
        error "Unknown command: $action"
        dotfile_usage
        ;;
esac

