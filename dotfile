#!/usr/bin/env sh

# shellcheck shell=ash
# This script assumes at least `local` extension is enabled.

# External sources available for install
readonly DOTFILE_AVAILABLE_SOURCES="native"

readonly DOTFILE_DEBUG=${DEBUG:-0}
readonly DOTFILE_LOG_LEVEL=${LOG_LEVEL:-2}

# XDG base directories
readonly XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
readonly XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}

## Logging functions
################################

# Source logging library
. _functions/logging.sh

## Utility functions
################################

# Source stack library
. _functions/stack.sh

# Source checker library
. _functions/checks.sh

## Dependency list creator
depends() {
    # Syntax: depends <src> <packages>...
    #   <src> can be `native`, `dotfile`, `pip`, `gem`, etc.
    #   There must be a function called install_<src> to install the
    #   dependencies.

    local src package arrayname
    src="$1"
    package="$2"
    shift 2

    # Allow packages from arbitrary sources
    arrayname="depends_$src"
    append "$package" to "$arrayname"

    # If there are more than one packages, recursively add more
    [ $# -ne 0 ] && depends "$src" "$@"
}

## Append one item to a space-separated list
append() {
    # Syntax: append <item> to <array>

    local item to array occurrence
    item=$1
    to=$2
    array=$3
    
    if [ $# -ne 3 ] || [ "$to" != "to" ]; then
        error "Usage: append <item> to <array>"
        exit 1
    fi

    does "$array" contain "$item"?
    if yes; then
        debug "$item already exists in $array."
        return
    fi

    eval "$array=\"\${$array} $item\""
}

## Install native package dependencies
install_native() {
    info "Installing native package dependencies..."
    info "You might need to provide your sudo credential here."
    # TODO: support other platforms as well
    #sudo pacman -Sy "$@"
    #sudo apt-get install "$@"
}

## Install dotfile package dependencies
install_dotfile() {
    info "Installing dotfile dependencies..."
    for pkg in $depends_dotfile; do
        dotfile_install "$pkg"
    done
}

## Action handlers
################################

dotfile_usage() {
    cat 1>&2 <<EOF
USAGE:
    $(basename "$0") <command>

COMMANDS:
    init         Initializes this machine.
    install      Installs a package to this machine.
    uninstall    Uninstalls a package from this machine.
    update       Updates the repository to the most recent version.
    remove       Remove all packages and try to make as clean as possible.
    help         Displays this help message.
EOF

    if [ "$DOTFILE_DEBUG" -ne 0 ]; then
        echo "    shell        Create a REPL instance. Useful when debugging functions."
    fi
}

dotfile_init() {
    # Initialization routine
    # Things to do:
    # 1. Create configuration file $XDG_CONFIG_HOME/dotfile.conf
    # 2. Create package folder $XDG_DATA_HOME/dotfile/
    # 3. Verify all necessary binaries are here (git, stow, etc.)
    # 4. Symbolic link itself to ~/.local/bin

    # Create basic configuration file
    is "$XDG_CONFIG_HOME/dotfile.conf" a file?
    if no; then
        info "Dotfile configuration file is not found. Creating..."
        ensure mkdir -p "$XDG_CONFIG_HOME"
        ensure touch "$XDG_CONFIG_HOME/dotfile.conf"

        info "Setting dotfile home directory as:"
        echo "dotfile_home=$(dirname "$(realpath "$0")")" \
            | ensure tee "$XDG_CONFIG_HOME/dotfile.conf" \
            1>&2
    fi

    # Create directory where package data will be stored
    is "$XDG_DATA_HOME/dotfile" a directory?
    if no; then
        info "Dotfile package storage is not found. Creating..."
        ensure mkdir -p "$XDG_DATA_HOME/dotfile"
    fi

    # git is required to update packages
    is git a command?
    if no; then
        info "git does not exist. Attempting to install..."
        ensure install_native git
    fi

    # stow is required to make symbolic links
    is stow a command?
    if no; then
        info "stow does not exist. Attempting to install..."
        ensure install_native stow
    fi

    # This script is going to be installed in local PATH
    is "$HOME/.local/bin/dotfile" a symlink?
    if no; then
        info "Installing dotfile binary to local binary directory..."
        ensure mkdir -p "$HOME/.local/bin"
        ensure ln -s "$(realpath "$0")" "$HOME/.local/bin/dotfile"
    fi
}

dotfile_install() {
    local pkg
    pkg="$1"

    debug "Installing dotfile package $pkg..."

    # Check package sanity
    is "$pkg" a directory?
    if no; then
        error "Dotfile package $pkg is not found! Aborting..."
        exit 2
    fi

    is "$pkg/dotpkg" a file?
    if no; then
        error "$pkg is not a valid dotfile package. Aborting..."
        exit 2
    fi

    # Check circular dependency
    does "$(stack_name ancestors)" contain "$pkg"?
    if yes; then
        warn "Circular dependency detected! Ignoring the last attempt to install $pkg..."
        warn "You may want to fix the package description file to resolve this issue."
        return
    fi

    # If already visited, then do nothing
    does "visited" contain "$pkg"?
    if yes; then
        debug "Package $pkg is already installed by other package. Skipping..."
        return
    fi

    # Load dotfile description file
    . "$pkg/dotpkg"

    # Mark current package as visited
    append "$pkg" to "visited"

    # Find out the direct dependencies
    local difference
    difference="$depends_dotfile"
    for visited_pkg in $visited; do
        difference=$(echo "$difference" | sed -E -e "s/^$visited_pkg | $visited_pkg|$visited_pkg | $visited_pkg\$//g")
    done

    # Install dependencies first
    stack_push ancestors "$pkg"
    for dependency in $difference; do
        dotfile_install "$dependency"
    done
    stack_pop ancestors > /dev/null

    # Unset pre- and post-installation hooks
    unset -f pre_install post_install

    # Source dotfile description file again to restore changed hooks
    . "$pkg/dotpkg"

    # Run the pre-installation hook
    maybe pre_install

    # Install external dependencies
    for src in $DOTFILE_AVAILABLE_SOURCES; do
        debug "Installing dependencies from $src..."
        eval "install_$src \$depends_$src"

        # Clear external dependency list after installation
        unset "depends_$src"
    done

    # Stow the directory
    debug "Symlinking the configuration files..."
    ensure stow -t "$HOME" --ignore=".gitignore" --ignore="dotpkg" "$pkg"

    # Copy description file to the data directory
    ensure cp "$pkg/dotpkg" "$XDG_DATA_HOME/dotfile/$pkg"

    # Run the post-installation hook
    maybe post_install

    return
}

dotfile_uninstall() {
    error "This feature is not implemented yet."
    return
}

dotfile_update() {
    error "This feature is not implemented yet."
    return
}

dotfile_remove() {
    error "This feature is not implemented yet."
    return
}

dotfile_shell() {
    if [ "$DOTFILE_DEBUG" -eq 0 ]; then
        error "Opening shell is not supported if DEBUG environment variable is not set!"
        exit 1
    fi

    while true; do
        read -r -p "dotfile> " line

        [ "$line" = "exit" ] && break

        eval "$line"
    done
}

## Entrypoint
################################

# Take the first positional argument
action="$1"
if [ -z "$action" ]; then
    error "You must supply at least one command!"
    dotfile_usage
    return 1
fi
shift

case "$action" in
    help)
        echo "dotfile -- automatic dotfile installer, because I am lazy as fuck"
        echo ""
        dotfile_usage
        ;;

    init)
        dotfile_init "$@"
        ;;

    install)
        dotfile_install "$@"
        ;;

    uninstall)
        dotfile_uninstall "$@"
        ;;

    update)
        dotfile_update "$@"
        ;;

    remove)
        dotfile_remove "$@"
        ;;

    shell)
        dotfile_shell "$@"
        ;;

    *)
        error "Unknown command: $action"
        dotfile_usage
        ;;
esac

