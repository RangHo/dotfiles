#!/usr/bin/env sh

# shellcheck shell=ash
# This script assumes at least `local` extension is enabled.

# External sources available for install
readonly DOTFILE_AVAILABLE_SOURCES="native"

readonly DOTFILE_DEBUG=${DEBUG:-0}
readonly DOTFILE_LOG_LEVEL=${LOG_LEVEL:-2}

# XDG base directories
readonly XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
readonly XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
readonly XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}

## Logging functions
################################

# Color constants
readonly BLACK=$(tput setaf 0)
readonly RED=$(tput setaf 1)
readonly GREEN=$(tput setaf 2)
readonly YELLOW=$(tput setaf 3)
readonly BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly CYAN=$(tput setaf 6)
readonly WHITE=$(tput setaf 7)

# Text style constants
readonly BOLD=$(tput bold)
readonly UNDERLINE=$(tput smul)
readonly BLINK=$(tput blink)

# Reset test to normal style
readonly NORMAL=$(tput sgr0)

debug() {
    [ "$DOTFILE_DEBUG" -eq 0 ] && [ "$DOTFILE_LOG_LEVEL" -lt 3 ] && return
    printf "[${BOLD}${WHITE}DEBUG${NORMAL}] ${WHITE}%s${NORMAL}\n" "$@" >&2
}

info() {
    [ "$DOTFILE_LOG_LEVEL" -lt 2 ] && return
    printf "[${BOLD}${BLUE}INFO${NORMAL}] ${WHITE}%s${NORMAL}\n" "$@" >&2
}

warn() {
    [ "$DOTFILE_LOG_LEVEL" -lt 1 ] && return
    printf "[${BOLD}${YELLOW}WARNING${NORMAL}] ${WHITE}%s${NORMAL}\n" "$@" >&2
}

error() {
    printf "[${BOLD}${RED}ERROR${NORMAL}] ${WHITE}%s${NORMAL}\n" "$@" >&2
}


## Utility functions
################################

## Push a new item to stack
stack_push() {
    # Syntax: stack_push <stack_id> <item>

    if [ "$#" -ne 2 ]; then
        error "Usage: stack_push <stack_id> <item>"
        return 1
    fi

    local stack_id item
    stack_id="$1"
    item="$2"

    eval "stack_$stack_id=\"\${stack_$stack_id} $item\""
}

## Pop an item from stack to stdout
stack_pop() {
    # Syntax: stack_pop <stack_id>

    if [ "$#" -ne 1 ]; then
        error "Usage: stack_pop <stack_id>"
        return 1
    fi

    local stack_id result
    stack_id="$1"
    result=$(eval "echo \${stack_$stack_id}" | awk -F ' ' '{ print $NF }')

    # Check if the result is empty
    if [ -z "$result" ]; then
        warn "Stack is already empty."
        return
    fi

    # Remove the item from the end
    eval "stack_$stack_id=\$(echo \"\${stack_$stack_id}\" | sed -e 's/ $result$//')"

    # Print the last element to stdout
    echo $result
}

## Print the content of the stack
stack_print() {
    # Syntax: stack_print <stack_id>

    if [ "$#" -ne 1 ]; then
        error "Usage: stack_print <stack_id>"
        return 1
    fi

    local stack_id
    stack_id="$1"

    eval "echo \${stack_$stack_id}"
}

## Print the name of the stack
stack_name() {
    # Syntax: stack_name <stack_id>

    if [ "$#" -ne 1 ]; then
        error "Usage: stack_name <stack_id>"
        return 1
    fi

    local stack_id
    stack_id="$1"

    echo "stack_$stack_id"
}

## Ensure a command succeeds
ensure() {
    if ! "$@"; then
        error "Command failed: $*"
        error "This command is required. Cannot proceed..."
        exit 1
    fi
}

## Maybe a command exists
maybe() {
    is $1 a command?
    yes && "$@" || debug "No such command: $1"
}

## is-checks
is() {
    # Syntax: is <subject> a/an <complement>?

    local subject article complement
    subject="$1"
    article="$2"
    complement=$(echo "$3" | sed -e 's/\?$//')

    if [ "$#" -ne 3 ] || [ "$article" != "a" ] && [ "$article" != "an" ]; then
        error "Usage: is <subject> a(n) <complement>?"
        return 1
    fi

    case "$complement" in
        command) command -v "$subject" > /dev/null ;;
        file) [ -e "$subject" ] ;;
        directory) [ -d "$subject" ] ;;
        symlink) [ -L "$subject" ] ;;

        *)
            error "<complement> can be either command, file, directory, or symlink."
            false
            ;;
    esac && checks_last_result="yes" || checks_last_result="no"
}

## does-checks
does() {
    # Syntax: does <subject> <verb> <object>?

    local subject verb object
    subject="$1"
    verb="$2"
    object=$(echo "$3" | sed -e 's/\?$//')

    if [ "$#" -ne 3 ]; then
        error "Usage: does <subject> <verb> <object>?"
        return 1
    fi

    case "$verb" in
        contain) does_contain "$subject" "$object" ;;

        *)
            error "<verb> must be contain."
            false
            ;;
    esac && checks_last_result="yes" || checks_last_result="no"

}

## Check if the "array" contains the item
does_contain() {
    local array item occurrence
    array=$1
    item=$2
    occurrence=$(printf "%s\n" $(eval "echo \"\$$array\"") | grep -c "^$item$")

    [ "$occurrence" -ne 0 ]
}

## Yes check
yes() {
    [ "$checks_last_result" = "yes" ]
}

## No check
no() {
    [ "$checks_last_result" != "yes" ]
}


## Dependency list creator
depends() {
    # Syntax: depends <src> <packages>...
    #   <src> can be `native`, `dotfile`, `pip`, `gem`, etc.
    #   There must be a function called install_<src> to install the
    #   dependencies.

    local src package arrayname
    src="$1"
    package="$2"
    shift 2

    # Allow packages from arbitrary sources
    arrayname="depends_$src"
    append "$package" to "$arrayname"

    # If there are more than one packages, recursively add more
    [ $# -ne 0 ] && depends "$src" "$@"
}

## Append one item to a space-separated list
append() {
    # Syntax: append <item> to <array>

    local item to array occurrence
    item=$1
    to=$2
    array=$3

    if [ $# -ne 3 ] || [ "$to" != "to" ]; then
        error "Usage: append <item> to <array>"
        exit 1
    fi

    does "$array" contain "$item"?
    if yes; then
        debug "$item already exists in $array."
        return
    fi

    eval "$array=\"\${$array} $item\""
}

## Install native package dependencies
install_native() {
    debug "Installing native packages: $@"

    # Check if the user can access sudo
    if ! sudo -v -p "Installing native packages requires sudo:"; then
        printf "%s\n" $@ > $XDG_CACHE_HOME/native_pkgs.txt

        if ! [ dotfile_sudo_warned ]; then
            warn "This account doesn't seem to have sudo access!"
            warn "You may have to install some packages yourself."
            warn "Refer to the native_pkgs.txt in ${XDG_CACHE_HOME} directory"
            warn "after this command exits."

            dotfile_sudo_warned="yes"
        fi
        return
    fi

    # TODO: support other platforms as well
    #sudo pacman -Sy "$@"
    #sudo apt-get install "$@"
}

## Install dotfile package dependencies
install_dotfile() {
    info "Installing dotfile dependencies..."
    for pkg in $depends_dotfile; do
        dotfile_install "$pkg"
    done
}

## Action handlers
################################

dotfile_usage() {
    cat 1>&2 <<EOF
USAGE:
    $(basename "$0") <command>

COMMANDS:
    init         Initializes this machine.
    install      Installs a package to this machine.
    uninstall    Uninstalls a package from this machine.
    update       Updates the repository to the most recent version.
    remove       Remove all packages and try to make as clean as possible.
    help         Displays this help message.
EOF

if [ "$DOTFILE_DEBUG" -ne 0 ]; then
    echo "    shell        Create a REPL instance. Useful when debugging functions."
fi
}

dotfile_init() {
    # Initialization routine
    # Things to do:
    # 1. Create configuration file $XDG_CONFIG_HOME/dotfile.conf
    # 2. Create package folder $XDG_DATA_HOME/dotfile/
    # 3. Verify all necessary binaries are here (git, stow, etc.)
    # 4. Symbolic link itself to ~/.local/bin

    # Create basic configuration file
    is "$XDG_CONFIG_HOME/dotfile.conf" a file?
    if no; then
        info "Dotfile configuration file is not found. Creating..."
        ensure mkdir -p "$XDG_CONFIG_HOME"
        ensure touch "$XDG_CONFIG_HOME/dotfile.conf"

        info "Setting dotfile home directory as:"
        echo "dotfile_home=$(dirname "$(realpath "$0")")" \
            | ensure tee "$XDG_CONFIG_HOME/dotfile.conf" \
            1>&2
    fi

    # Create directory where package data will be stored
    is "$XDG_DATA_HOME/dotfile" a directory?
    if no; then
        info "Dotfile package storage is not found. Creating..."
        ensure mkdir -p "$XDG_DATA_HOME/dotfile"
    fi

    # git is required to update packages
    is git a command?
    if no; then
        info "git does not exist. Attempting to install..."
        ensure install_native git
    fi

    # stow is required to make symbolic links
    is stow a command?
    if no; then
        info "stow does not exist. Attempting to install..."
        ensure install_native stow
    fi

    # This script is going to be installed in local PATH
    is "$HOME/.local/bin/dotfile" a symlink?
    if no; then
        info "Installing dotfile binary to local binary directory..."
        ensure mkdir -p "$HOME/.local/bin"
        ensure ln -s "$(realpath "$0")" "$HOME/.local/bin/dotfile"
    fi
}

dotfile_install() {
    if [ "$#" -ne 1 ]; then
        error "You must provide one package!"
        error "Usage: dotfile install <package>"
        return 1
    fi

    local pkg
    pkg="$1"

    debug "Installing dotfile package $pkg..."

    # Check package sanity
    is "$pkg" a directory?
    if no; then
        error "Dotfile package $pkg is not found! Aborting..."
        exit 2
    fi

    is "$pkg/dotpkg" a file?
    if no; then
        error "$pkg is not a valid dotfile package. Aborting..."
        exit 2
    fi

    # Check circular dependency
    does "$(stack_name ancestors)" contain "$pkg"?
    if yes; then
        warn "Circular dependency detected! Ignoring the last attempt to install $pkg..."
        warn "You may want to fix the package description file to resolve this issue."
        return
    fi

    # If already visited, then do nothing
    does "visited" contain "$pkg"?
    if yes; then
        debug "Package $pkg is already installed by other package. Skipping..."
        return
    fi

    # Load dotfile description file
    . "$pkg/dotpkg"

    # Mark current package as visited
    append "$pkg" to "visited"

    # Find out the direct dependencies
    local difference
    difference="$depends_dotfile"
    for visited_pkg in $visited; do
        difference=$(echo "$difference" | sed -E -e "s/^$visited_pkg | $visited_pkg|$visited_pkg | $visited_pkg\$//g")
    done

    # Install dependencies first
    stack_push ancestors "$pkg"
    for dependency in $difference; do
        dotfile_install "$dependency"
    done
    stack_pop ancestors > /dev/null

    # Unset pre- and post-installation hooks
    unset -f pre_install post_install

    # Source dotfile description file again to restore changed hooks
    . "$pkg/dotpkg"

    # Run the pre-installation hook
    maybe pre_install

    # Install external dependencies
    for src in $DOTFILE_AVAILABLE_SOURCES; do
        debug "Installing dependencies from $src..."
        eval "install_$src \$depends_$src"

        # Clear external dependency list after installation
        unset "depends_$src"
    done

    # Stow the directory
    debug "Symlinking the configuration files..."
    ensure stow -t "$HOME" --ignore=".gitignore" --ignore="dotpkg" "$pkg"

    # Copy description file to the data directory
    ensure cp "$pkg/dotpkg" "$XDG_DATA_HOME/dotfile/$pkg"

    # Run the post-installation hook
    maybe post_install

    return
}

dotfile_uninstall() {
    error "This feature is not implemented yet."
    return
}

dotfile_update() {
    error "This feature is not implemented yet."
    return
}

dotfile_remove() {
    error "This feature is not implemented yet."
    return
}

dotfile_shell() {
    if [ "$DOTFILE_DEBUG" -eq 0 ]; then
        error "Opening shell is not supported if DEBUG environment variable is not set!"
        exit 1
        fi

        while true; do
            read -r -p "dotfile> " line

            [ "$line" = "exit" ] && break

            eval "$line"
        done
    }

## Entrypoint
################################

# Take the first positional argument
action="$1"
if [ -z "$action" ]; then
    error "You must supply at least one command!"
    dotfile_usage
    return 1
fi
shift

# Display help message
if [ "$action" = "help" ]; then
    echo "dotfile -- automatic dotfile installer, because I am lazy as fuck"
    echo ""
    dotfile_usage
    exit
fi

# If there is no dotfile configuration file, instruct the user to run
# `dotfile init` first
is "$XDG_CONFIG_HOME/dotfile.conf" a file?
if no && [ "$action" != "init" ]; then
    error "Dotfile manager is not initialized yet!"
    error "Please run \"dotfile init\" first."
    exit 1
fi

# Go to the dotfile home directory
ensure . "$XDG_CONFIG_HOME/dotfile.conf"
debug "Changing directory to $dotfile_home..."
dotfile_old_pwd="$(pwd)"
cd "$dotfile_home"

case "$action" in
    init)
        dotfile_init "$@"
        ;;

    install)
        dotfile_install "$@"
        ;;

    uninstall)
        dotfile_uninstall "$@"
        ;;

    update)
        dotfile_update "$@"
        ;;

    remove)
        dotfile_remove "$@"
        ;;

    shell)
        dotfile_shell "$@"
        ;;

    *)
        error "Unknown command: $action"
        dotfile_usage
        ;;
esac

# Restore the directory
cd "$dotfile_old_pwd"

